# /dev - Aggressive Parallel Development Workflow

## Core Feature: Unlimited Parallel Codex Execution

This workflow's **defining characteristic** is aggressive, unrestricted parallel Codex invocation:

- **No task count limits** - decompose into as many tasks as beneficial
- **No invocation limits** - call Codex as many times as needed
- **Maximum concurrency** - if tasks CAN run in parallel, they MUST
- **High-intensity execution** - push project progress at full speed

## Overview

A lightweight development workflow designed to maximize velocity through massive parallel execution.

## Flow

```
/dev trigger
  ↓
Fast Path check (single-file? <100 lines?)
  ├─ Yes → Direct Edit → Test → Done
  └─ No ↓
Step 1: Clarify (CONDITIONAL - skip if clear)
  ↓
Step 2: Analysis (SMART - direct tools or wrapper)
  ↓
Step 3: Generate dev-plan.md
  ↓
Step 4: Parallel execution (unlimited tasks)
  ↓
Step 5: Coverage validation (iterative)
  ↓
Step 6: Done
```

## The 6 Steps

### 1. Clarify Requirements (CONDITIONAL)
- **Skip when**: single-file fix, doc update, clear implementation path
- **Ask when**: new feature, architecture change, vague requirements
- 2–3 rounds of Q&A if needed

### 2. Technical Analysis (SMART DELEGATION)
- **Small-scope** (≤3 files, <500 lines): Use Read/Glob/Grep directly
- **Large-scope** (global search, architecture): Use codeagent-wrapper
- UI auto-detection: component files + style usage → gemini backend

### 3. Generate Dev Doc
- Call the **dev-plan-generator** agent
- Produce a single `dev-plan.md`
- Task count is unlimited - decompose as finely as beneficial for parallelization
- Include: task breakdown, file scope, dependencies, test commands

### 4. Concurrent Development
- Work from the task list in dev-plan.md
- Use codeagent-wrapper per task with explicit backend selection:
  - Backend/API/DB tasks → `--backend codex` (default)
  - UI/style/component tasks → `--backend gemini` (enforced)
- Independent tasks → run in parallel (maximize concurrency)
- Conflicting tasks → run serially
- **Aggressive parallelization**: Always prefer more parallel tasks over fewer sequential ones

### 5. Testing & Verification (ITERATIVE)
- Auto-retry 2 rounds → then ask user
- Exit when: coverage met / user stops / no improvement
- Coverage: ≥90% (backend) / ≥70% (UI)

### 6. Complete
- Summarize task status
- Record coverage

## Usage

```bash
/dev "Implement user login with email + password"
```

**No options**, fixed workflow, works out of the box.

## Output Structure

```
.claude/specs/{feature_name}/
└──  dev-plan.md      # Dev document generated by agent
```

Only one file—minimal and clear.

## Core Components

### Tools
- **AskUserQuestion**: interactive requirement clarification
- **codeagent-wrapper**: analysis, development, testing; supports `--backend` for codex (default) or gemini (UI)
- **dev-plan-generator agent**: generate dev doc (subagent via Task tool, saves context)

## UI Auto-Detection & Backend Routing
- **UI detection standard**: BOTH conditions must be met:
  1. Frontend component files exist (.tsx, .jsx, .vue)
  2. Style usage detected (CSS imports, className/class, styled-components, CSS modules, Tailwind classes)
- **Pure logic components**: Do NOT trigger `needs_ui: true`
- **Flow impact**: Step 2 auto-detects UI work; Step 3 appends a separate UI task in `dev-plan.md` when detected
- **Backend split**: backend/API tasks use codex backend (default); UI tasks force gemini backend
- **Implementation**: Orchestrator invokes codeagent skill with appropriate backend parameter per task type

## Key Features

### ✅ Fast Path
- Single-file edits (<100 lines) skip Step 1-4
- Direct Edit → Test → Done
- Fallback to full workflow on failure

### ✅ Smart Delegation
- Small-scope (≤3 files): Use tools directly
- Large-scope: Use codeagent-wrapper
- Conditional clarification (skip when clear)

### ✅ Unlimited Concurrency
- No artificial task count limits
- Aggressive parallel Codex invocation
- Auto-detect dependencies and conflicts

### ✅ Iterative Coverage
- Auto-retry 2 rounds
- User confirmation for round 3+
- Exit on: met / stopped / no improvement

## Examples

### Example 1: Fast Path (Single-file fix)

```bash
/dev "fix null pointer at src/auth/login.ts line 42"

# Fast Path: eligible (single file, <100 lines)
→ Read src/auth/login.ts
→ Edit line 42: add null check
→ pytest tests/test_login.py → Pass
→ Done (skipped Step 1-4)
```

### Example 2: Standard Flow (New feature)

```bash
/dev "Add user login feature"

# Step 1: Clarify (required - new feature)
Q: Login methods? A: Email + password
Q: Remember login? A: Yes, JWT token

# Step 2: Analysis (large-scope → wrapper)
→ codeagent-wrapper analysis
→ Tasks: Backend API, Password hashing, Frontend form
→ UI detected: .tsx + Tailwind

# Step 3-5: Generate → Execute → Verify
→ dev-plan.md generated
→ 3 parallel tasks (codex + gemini)
→ Coverage: 92%, 95%, 75% ✓
```

### Example 3: Smart Delegation (Small-scope)

```bash
/dev "add input validation to src/auth/register.ts"

# Step 1: Skip (clear implementation path)
# Step 2: Small-scope (1 file) → Read directly
→ Read src/auth/register.ts
→ Identify validation points

# Step 3-5: Standard flow
→ dev-plan.md with 2 tasks
→ Execute → 91% coverage ✓
```

## Directory Structure

```
dev-workflow/
├── README.md                          # This doc
├── commands/
│   └── dev.md                         # /dev workflow orchestrator definition
└── agents/
    └── dev-plan-generator.md          # Dev plan document generator agent
```

Minimal structure, only three files.

## When to Use

✅ **Good for**:
- Any feature size
- Fast iterations
- High test coverage needs
- Wanting concurrent speed-up

## Design Principles

1. **Unlimited parallelization**: maximize Codex concurrency, no artificial limits
2. **Quality first**: enforce 90% coverage (backend) / 70% (UI)
3. **Aggressive execution**: push project progress at full speed
4. **Smart delegation**: right tool for right scope
5. **Fast path first**: simple tasks skip overhead

---

## Performance Benchmark

| Scenario | Fast Path | Standard Flow | Savings |
|----------|-----------|---------------|---------|
| Single-line fix | ~30s | ~3-5min | **85%** |
| Single-file refactor | ~1min | ~5-8min | **80%** |
| Multi-file feature | N/A | ~10-15min | - |

**Fast Path triggers**:
- Single file, <100 lines changed
- No cross-file dependencies
- Clear implementation path

**When to use Standard Flow**:
- New features (unclear scope)
- Architecture changes
- Multi-module changes

---

**Philosophy**: Unleash the full power of parallel Codex execution—ship fast, ship quality.
